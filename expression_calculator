#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <set>
//#include <chrono>
//#include <random>

enum IOType
{
    INTEGER,
    ADD,
    SUBTRACT,
    MULTIPLY,
    DIVIDE,
    LEFT_PAR,
    RIGHT_PAR
};


std::map<IOType, char> operator_map =
        {
                {ADD, '+' },
                {SUBTRACT, '-' },
                {MULTIPLY, '*' },
                {DIVIDE, '/' },
                {LEFT_PAR, '(' },
                {RIGHT_PAR, ')' }
        };


IOType OperatorToIOType(char operator_char)
{
    if (operator_char == '+')
        return ADD;
    else if (operator_char == '-')
        return SUBTRACT;
    else if (operator_char == '*')
        return MULTIPLY;
    else if (operator_char == '/')
        return DIVIDE;
    else if (operator_char == '(')
        return LEFT_PAR;
    else if (operator_char == ')')
        return RIGHT_PAR;
    else
    {
        std::cout << "Invalid operator!" << std::endl;
        exit(1);
    }
}


char IOTypeToOperator(IOType ioType)
{

    if (ioType == ADD)
        return '+';
    else if (ioType == SUBTRACT)
        return '-';
    else if (ioType == MULTIPLY)
        return '*';
    else if (ioType == DIVIDE)
        return '/';
    else if (ioType == LEFT_PAR)
        return '(';
    else if (ioType == RIGHT_PAR)
        return ')';
    else
    {
        std::cout << "Invalid IOType for operator!" << std::endl;
        exit(1);
    }
}

int precedence(char op)
{
    if(op == '(' || op == ')')
        return 0;
    else if(op == '+' || op == '-')
        return 1;
    else if(op == '*' || op == '/')
        return 2;

    throw 0;
}


class IntegerOrOperator
{
public:
    IOType type;
    double value;
    char op;
    explicit IntegerOrOperator(int v = 0) :
            type(INTEGER),
            value(v),
            op(' ')
    {
    }
    explicit IntegerOrOperator(char o = ' ') :
            type(OperatorToIOType(o)),
            value(0),
            op(o)
    {
    }
};

class Node;
std::ostream& operator<< (std::ostream&, const Node*);

class Node
{
public:
    IntegerOrOperator* value;
    std::vector<Node*> child;
    Node* parent;
    explicit Node(IntegerOrOperator* v = nullptr) { value = v; }
    void addChild(Node* ch)
    {
        std::cout << this << "->addChild(" << ch << ") " << std::endl;
        child.push_back(ch);
        ch->setParent(this);
        //std::cout << ch << "->parent: "<< this << std::endl;
    }
    void setParent(Node* p)
    {
        parent = p;
        //std::cout << this << "->parent: "<< parent << std::endl;
    }

};

std::ostream& operator<< (std::ostream &out, const Node* node)
{
    if (node)
    {
        if (node->value->type == INTEGER)
            out << node->value->value;
        else
            out << IOTypeToOperator(node->value->type);
    }
    else
        out << "nullptr";
    return out;
}

std::string PrintSet(std::set<Node*>& seen)
{
    if (seen.empty())
    {
        return "{}";
    }
    else
    {
        std::string x="{";
        for (Node* n : seen)
        {
            if (n)
            {
                if (n->value->type == INTEGER)
                {
                    x.append(std::to_string(n->value->value));
                    x.append(", ");
                }
                else
                {
                    x.append(std::string(1,IOTypeToOperator(n->value->type)));
                    x.append(", ");
                }
            }
        }
        x.pop_back();
        x.pop_back();
        x.append("}");
        return x;
    }
}

bool CheckAndPrint(Node* node, std::set<Node*>& seen)
{
    std::cout << "CheckAndPrint(" << node << ", " << PrintSet(seen) << ")" << std::endl;
    if (seen.count(node) == 0)
    {
        std::cout <<"Node checked: " << node << std::endl;
        seen.insert(node);
        std::cout << "seen = " << PrintSet(seen) << std::endl;
        return true;
    }
    return false;
}


void DFS(Node* node, std::set<Node*>& seen)
{
    std::cout << "DFS(" << node << ", " << PrintSet(seen) << ")" << std::endl;
    if (CheckAndPrint(node, seen))
    {
        for(auto ch : node->child)
            DFS(ch, seen);
    }
}

Node* ExecuteOperator(Node*);

void BFS(Node* node, std::set<Node*>& seen)
{
    std::cout << "BFS(" << node << ", " << PrintSet(seen) << ")" << std::endl;
    CheckAndPrint(node, seen);
    std::set<Node*> tmp = seen;
    //std::cout << "tmp: " << PrintSet(tmp) << std::endl;
    int j=0;
    for(auto ch : node->child)
    {
        if (ch->child.empty() && ch->value->type == INTEGER)
        {
            std::cout << "child: " << ch << std::endl;

        }
        else
            j++;

        CheckAndPrint(ch, seen);
    }

    if (node->child.size()==2 && j==0)
    {
        std::cout << "Operator can be executed: " << node << std::endl;
        std::cout << "BEFORE EXECUTION: node: " << node << std::endl;
        std::cout << "BEFORE EXECUTION: node->child[0]: " << node->child[0] << std::endl;
        std::cout << "BEFORE EXECUTION: node->child[1]: " << node->child[1] << std::endl;
        std::cout << "BEFORE EXECUTION: seen: " << PrintSet(seen) << std::endl;

        seen.erase(node->child[0]);
        seen.erase(node->child[1]);
        ExecuteOperator(node);
        std::cout << "AFTER EXECUTION: node: " << node << std::endl;
        std::cout << "AFTER EXECUTION: seen.count(node): " << seen.count(node) << std::endl;
        std::cout << "AFTER EXECUTION: seen: " << PrintSet(seen) << std::endl;

    }


    for(auto ch : node->child)
    {
        if (tmp.count(ch) == 0)
            BFS(ch, seen);
    }

    std::cout << "------------------" << std::endl;
}


void PrintExpression(const std::vector<IntegerOrOperator*>& expression)
{
    for(auto x : expression)
    {
        if (x->type == INTEGER)
            std::cout << x->value << " ";
        else
            std::cout << IOTypeToOperator(x->type) << " ";
    }
    std::cout << std::endl;
}

int precedence(Node* node)
{
    if(node->value->type == ADD || node->value->type == SUBTRACT)
        return 1;
    else if(node->value->type == MULTIPLY || node->value->type == DIVIDE)
        return 2;
    throw "0";
}


bool isOperator(IOType ioType)
{
    std::set<IOType> opsSet = {ADD, SUBTRACT, MULTIPLY, DIVIDE};
    return opsSet.count(ioType) > 0;
}

bool isOperator2(IOType ioType)
{
    if (ioType == ADD || ioType == SUBTRACT || ioType == MULTIPLY || ioType == DIVIDE)
        return true;
    else
        return false;
}


std::vector<IntegerOrOperator*> expression(const std::string& str_expr)
{
    std::vector<IntegerOrOperator*> expr;
    for(auto i = 0; i < str_expr.size(); ++i)
    {
        while (str_expr[i] == ' ')
            i++;
        if (i >= str_expr.size())
            break;
        if (expr.empty() && (str_expr[i] == '+' || str_expr[i] == '-'))
            expr.push_back(new IntegerOrOperator(0));
        if (!isdigit(str_expr[i]))
            expr.push_back(new IntegerOrOperator(str_expr[i]));
        else
        {
            if (i > 0 && str_expr[i-1] != ' ' && expr.back()->type == INTEGER)
            {
                expr.back()->value = stoi(std::to_string(int(expr.back()->value))+std::to_string(str_expr[i] - '0'));
            }
            else
            {
                expr.push_back(new IntegerOrOperator(int(str_expr[i] - '0')));
            }

        }
    }
    return expr;
}


Node* ExecuteOperator(Node* node)
{
    std::cout << "node: " << node << std::endl;
    if (node->child.empty())
    {
        if (node->value->type == INTEGER)
            return node;
        else
        {
            std::cout << "Invalid expression!0" << std::endl;
            exit(1);
        }
    }
    else if (node->child.size() == 1)
    {
        std::cout << "Invalid expression!1" << std::endl;
        exit(1);
    }
    else if (node->child.size() == 2)
    {
        std::cout << node << "->child[0]: " << node->child[0] << std::endl;
        std::cout << node << "->child[1]: " << node->child[1] << std::endl;
        if (node->child[0]->value->type == INTEGER && node->child[1]->value->type == INTEGER)
        {

            if (node->value->type == ADD)
                node->value->value = node->child[0]->value->value + node->child[1]->value->value;
            else if (node->value->type == SUBTRACT)
                node->value->value = node->child[0]->value->value - node->child[1]->value->value;
            else if (node->value->type == MULTIPLY)
                node->value->value = node->child[0]->value->value * node->child[1]->value->value;
            else if (node->value->type == DIVIDE)
            {
                if (node->child[1]->value->value != 0)
                    node->value->value = node->child[0]->value->value / node->child[1]->value->value;
                else
                {
                    std::cout << "Zero divisor!" << std::endl;
                    exit(1);
                }
            }

            node->value->type = INTEGER;

            delete node->child[1];
            node->child.pop_back();

            delete node->child[0];
            node->child.pop_back();
        }
        else
        {


            std::cout << "FFFFFFFFFFFFFFFFFFFFFFFFFFFF" << std::endl;
            exit(1);



            /*
            for(auto ch : node->child)
            {
                std::cout << "ExecuteOperator(" << ch << ")" << std::endl;
                ExecuteOperator(ch);
            }


            std::cout << "node XXX: " << node << std::endl;
            ExecuteOperator(parent);
            std::cout << "node YYY: " << node << std::endl;
             */
        }
    }

    return node;
}


double evaluate(const std::vector<IntegerOrOperator*>& expression)
{
    Node* prevNode = nullptr;
    Node* newNode = nullptr;
    Node* root = nullptr;
    Node* prevOp = nullptr;

    for(auto x : expression)
    {
        newNode = new Node(x);
        std::cout << "newNode: " << newNode << std::endl;
        std::cout << "prevNode: " << prevNode << std::endl;

        if (isOperator(newNode->value->type))
        {
            if (prevNode)
            {
                if (prevOp)
                {
                    if (precedence(prevOp) < precedence(newNode))
                    {
                        prevOp->child.push_back(newNode);
                        std::cout << prevOp << "->child.push_back(" << newNode << ")" << std::endl;
                        newNode->child.push_back(prevNode);
                        std::cout << newNode << "->child.push_back(" << prevNode << ")" << std::endl;
                    }
                    else
                    {
                        newNode->child.push_back(root); // (+) gyereke a  (-)
                        std::cout << newNode << "->child.push_back(" << root << ")" << std::endl;
                        prevOp->child.push_back(prevNode); // (-) gyereke a (100)
                        std::cout << prevOp << "->child.push_back(" << prevNode << ")" << std::endl;

                        root = newNode;
                        prevOp=newNode;
                        std::cout << "root: 1 " << root << std::endl;
                        std::cout << "prevOp: 1 " << prevOp << std::endl;
                    }
                }
                else
                {
                    newNode->child.push_back(prevNode);
                    std::cout << newNode << "->child.push_back(" << prevNode << ")" << std::endl;

                    root=newNode;
                    std::cout << "root: 2 " << root << std::endl;

                    prevOp=newNode;
                    std::cout << "prevOp: 2 " << prevOp << std::endl;
                }

                if (isOperator(prevNode->value->type))
                {
                    prevNode->child.push_back(newNode);
                    std::cout << prevNode << "->child.push_back(" << newNode << ")" << std::endl;
                }
            }
            else
            {


            }
        }
        else if (newNode->value->type == LEFT_PAR)
        {


        }
        else
        {
            if (prevNode)
            {
                if (isOperator(prevNode->value->type))
                {
                    prevOp=prevNode;
                    std::cout << "prevOp: X" << prevOp << std::endl;
                }

                if (x == expression.back())
                {
                    std::cout << "prevOp: " << prevOp << std::endl;
                    std::cout << "LastNode: " << newNode << std::endl;
                    prevOp->child.push_back(newNode);

                }
            }
        }

        if (x != expression.back())
        {
            prevNode = newNode;
        }
        //std::cout << "--------------------------------------------" << std::endl;
    }

    std::cout << "root: " << root << std::endl;

    /*
    //ExecuteOperator(root,seen);
    while (!root->child.empty())
    {
        std::set<Node*> seen;
        BFS(root,seen);
    }


    std::cout << "Executed root value: " << root << std::endl;

    if(root)
    {
        if (root->value->type == INTEGER && root->child.empty())
        {
            double r = root->value->value;
            delete root;
            return r;
        }

    }
    */
    return 0.0;
}


int main()
{

    std::string s = "1000 + 100 * 15 / 77";
    std::vector<IntegerOrOperator*> e = expression(s);
    PrintExpression(e);

    std::cout << evaluate(e) << std::endl;


/*

    Node* plus = new Node(new IntegerOrOperator('+'));
    Node* n1 = new Node(new IntegerOrOperator(100));
    Node* n2 = new Node(new IntegerOrOperator(50));



    std::cout << "plus->child.size(): "<< plus->child.size() << std::endl;
    std::cout << plus << "->child.push_back(" << n1 << "): " << std::endl;
    plus->child.push_back(n1);
    std::cout << "plus->child.size(): "<< plus->child.size() << std::endl;
    int k = 0;
    for(auto c : plus->child)
    {
        std::cout << "plus->child[" << k << "] = " << c << std::endl;
        k++;
    }
    n1->parent = plus;
    std::cout << n1 << "->parent: "<< n1->parent << std::endl;
    std::cout << "------------------------" << std::endl;
    std::cout << plus << "->child.push_back(" << n2 << "): " << std::endl;
    plus->child.push_back(n2);
    std::cout << "plus->child.size(): "<< plus->child.size() << std::endl;
    int h = 0;
    for(auto c : plus->child)
    {
        std::cout << "plus->child[" << h << "] = " << c << std::endl;
        h++;
    }
    n2->parent = plus;
    std::cout << n2 << "->parent: "<< n2->parent << std::endl;






    std::cout << "plus->child.size(): "<< plus->child.size() << std::endl;

    plus->addChild(n1);
    plus->addChild(n2);
    int h = 0;
    for(auto c : plus->child)
        std::cout << "plus->child[" << h++ << "] = " << c << std::endl;
    std::cout << n1 << "->parent: "<< n1->parent << std::endl;
    std::cout << n2 << "->parent: "<< n2->parent << std::endl;
    std::cout << "------------------------" << std::endl;

*/




    /*
    std::cout << "plus->value->value: "<< plus->value->value << std::endl;

    std::cout << n1 << " " << plus << " " << n2 << " = ";
    ExecuteOperator(plus);
    std::cout << plus << std::endl;

    std::cout << "plus->value->value: "<< plus->value->value << std::endl;


    Node* n1 = new Node(new IntegerOrOperator(100));
    Node* n2 = new Node(new IntegerOrOperator(100));
    n2 = n1;
    //std::set<Node*> seen;
    //seen.insert(n1);

    */
    //std::cout << isOperator(LEFT_PAR) << std::endl;
    /*
    std::default_random_engine generator;
    std::uniform_int_distribution<int> distribution(0,6);
    const int n = 1000000;

    auto t1 = std::chrono::high_resolution_clock::now();
    for (int i=0; i < n; ++i)
    {
        auto k = static_cast<IOType>(distribution(generator));
        isOperator(k);
    }
    auto t2 = std::chrono::high_resolution_clock::now();
    std::cout << "IsOp1: " << std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count() << std::endl;

    auto s1 = std::chrono::high_resolution_clock::now();
    for (int i=0; i < n; ++i)
    {
        auto k = static_cast<IOType>(distribution(generator));
        isOperator2(k);
    }
    auto s2 = std::chrono::high_resolution_clock::now();
    std::cout << "IsOp2: " << std::chrono::duration_cast<std::chrono::microseconds>(s2 - s1).count() << std::endl;

    const std::set<IOType> opsSet= {ADD, SUBTRACT, MULTIPLY, DIVIDE};
    auto z1 = std::chrono::high_resolution_clock::now();
    for (int i=0; i < n; ++i)
    {
        auto k = static_cast<IOType>(distribution(generator));
        isOperator3(k, opsSet);
    }
    auto z2 = std::chrono::high_resolution_clock::now();
    std::cout << "IsOp3: " << std::chrono::duration_cast<std::chrono::microseconds>(z2 - z1).count() << std::endl;

    */
    return 0;
}
